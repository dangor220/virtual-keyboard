const keyObj = {
  Backquote: {
    en: {
      sup: '~',
      char: '`',
    },
    ru: {
      char: 'ё',
    },
  },
  Digit1: {
    en: {
      sup: '!',
      char: '1',
    },
  },
  Digit2: {
    en: {
      sup: '@',
      char: '2',
    },
    ru: {
      sup: '"',
      char: '2',
    },
  },
  Digit3: {
    en: {
      sup: '#',
      char: '3',
    },
    ru: {
      sup: '№',
      char: '3',
    },
  },
  Digit4: {
    en: {
      sup: '$',
      char: '4',
    },
    ru: {
      sup: ';',
      char: '4',
    },
  },
  Digit5: {
    en: {
      sup: '%',
      char: '5',
    },
  },
  Digit6: {
    en: {
      sup: '^',
      char: '6',
    },
    ru: {
      sup: ':',
      char: '6',
    },
  },
  Digit7: {
    en: {
      sup: '&',
      char: '7',
    },
    ru: {
      sup: '?',
      char: '7',
    },
  },
  Digit8: {
    en: {
      sup: '*',
      char: '8',
    },
  },
  Digit9: {
    en: {
      sup: '(',
      char: '9',
    },
  },
  Digit0: {
    en: {
      sup: ')',
      char: '0',
    },
  },
  Minus: {
    en: {
      sup: '_',
      char: '-',
    },
  },
  Equal: {
    en: {
      sup: '+',
      char: '=',
    },
  },
  Backspace: {
    en: {
      char: 'Backspace ',
    },
  },
  Tab: {
    en: {
      char: 'Tab ',
    },
  },
  KeyQ: {
    en: {
      char: 'Q',
    },
    ru: {
      char: 'Й',
    },
  },
  KeyW: {
    en: {
      char: 'W',
    },
    ru: {
      char: 'Ц',
    },
  },
  KeyE: {
    en: {
      char: 'E',
    },
    ru: {
      char: 'У',
    },
  },
  KeyR: {
    en: {
      char: 'R',
    },
    ru: {
      char: 'К',
    },
  },
  KeyT: {
    en: {
      char: 'T',
    },
    ru: {
      char: 'Е',
    },
  },
  KeyY: {
    en: {
      char: 'Y',
    },
    ru: {
      char: 'Н',
    },
  },
  KeyU: {
    en: {
      char: 'U',
    },
    ru: {
      char: 'Г',
    },
  },
  KeyI: {
    en: {
      char: 'I',
    },
    ru: {
      char: 'Ш',
    },
  },
  KeyO: {
    en: {
      char: 'O',
    },
    ru: {
      char: 'Щ',
    },
  },
  KeyP: {
    en: {
      char: 'P',
    },
    ru: {
      char: 'З',
    },
  },
  BracketLeft: {
    en: {
      char: '[',
    },
    ru: {
      char: 'Х',
    },
  },
  BracketRight: {
    en: {
      char: ']',
    },
    ru: {
      char: 'Ъ',
    },
  },
  Backslash: {
    en: {
      sup: '/',
      char: '\\',
    },
  },
  Delete: {
    en: {
      char: 'Del',
    },
  },
  CapsLock: {
    en: {
      char: 'CapsLock',
    },
  },
  KeyA: {
    en: {
      char: 'A',
    },
    ru: {
      char: 'Ф',
    },
  },
  KeyS: {
    en: {
      char: 'S',
    },
    ru: {
      char: 'Ы',
    },
  },
  KeyD: {
    en: {
      char: 'D',
    },
    ru: {
      char: 'В',
    },
  },
  KeyF: {
    en: {
      char: 'F',
    },
    ru: {
      char: 'А',
    },
  },
  KeyG: {
    en: {
      char: 'G',
    },
    ru: {
      char: 'П',
    },
  },
  KeyH: {
    en: {
      char: 'H',
    },
    ru: {
      char: 'Р',
    },
  },
  KeyJ: {
    en: {
      char: 'J',
    },
    ru: {
      char: 'О',
    },
  },
  KeyK: {
    en: {
      char: 'K',
    },
    ru: {
      char: 'Л',
    },
  },
  KeyL: {
    en: {
      char: 'L',
    },
    ru: {
      char: 'Д',
    },
  },
  Semicolon: {
    en: {
      char: ';',
    },
    ru: {
      char: 'Ж',
    },
  },
  Quote: {
    en: {
      char: "'",
    },
    ru: {
      char: 'Э',
    },
  },
  Enter: {
    en: {
      char: 'ENTER',
    },
  },
  ShiftLeft: {
    en: {
      char: 'Shift',
    },
  },
  IntlBackslash: {
    en: {
      char: '\\',
    },
  },
  KeyZ: {
    en: {
      char: 'Z',
    },
    ru: {
      char: 'Я',
    },
  },
  KeyX: {
    en: {
      char: 'X',
    },
    ru: {
      char: 'Ч',
    },
  },
  KeyC: {
    en: {
      char: 'C',
    },
    ru: {
      char: 'С',
    },
  },
  KeyV: {
    en: {
      char: 'V',
    },
    ru: {
      char: 'М',
    },
  },
  KeyB: {
    en: {
      char: 'B',
    },
    ru: {
      char: 'И',
    },
  },
  KeyN: {
    en: {
      char: 'N',
    },
    ru: {
      char: 'Т',
    },
  },
  KeyM: {
    en: {
      char: 'M',
    },
    ru: {
      char: 'Ь',
    },
  },
  Comma: {
    en: {
      char: ',',
    },
    ru: {
      char: 'Б',
    },
  },
  Period: {
    en: {
      char: '.',
    },
    ru: {
      char: 'Ю',
    },
  },
  Slash: {
    en: {
      char: '/',
    },
    ru: {
      char: '.',
    },
  },
  ArrowUp: {
    en: {
      char: '',
    },
  },
  ShiftRight: {
    en: {
      char: 'Shift',
    },
  },
  ControlLeft: {
    en: {
      char: 'Ctrl',
    },
  },
  MetaLeft: {
    en: {
      char: 'Win',
    },
  },
  AltLeft: {
    en: {
      char: 'Alt',
    },
  },
  Space: {
    en: {
      char: 'Space',
    },
  },
  AltRight: {
    en: {
      char: 'Alt',
    },
  },
  ControlRight: {
    en: {
      char: 'Ctrl',
    },
  },
  ArrowLeft: {
    en: {
      char: '',
    },
  },
  ArrowDown: {
    en: {
      char: '',
    },
  },
  ArrowRight: {
    en: {
      char: '',
    },
  },
};

function generateKeyboard(obj, lang) {
  const keyboardBlock = document.createElement('div');
  const keyboardTextarea = document.createElement('textarea');
  const keyboardWrapper = document.createElement('div');

  keyboardTextarea.scrollTop = keyboardTextarea.scrollHeight;

  keyboardBlock.classList.add('keyboard');
  keyboardBlock.classList.add('_container');

  keyboardTextarea.classList.add('keyboard__textarea');
  keyboardWrapper.classList.add('keyboard__wrapper');

  keyboardTextarea.placeholder = 'Разработано в Windows\nСмена раскладки: Alt+Shift';

  document.body.insertAdjacentElement('afterbegin', keyboardBlock);
  document.body
    .querySelector('.keyboard')
    .insertAdjacentElement('afterbegin', keyboardWrapper);
  document.body
    .querySelector('.keyboard')
    .insertAdjacentElement('afterbegin', keyboardTextarea);

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const keyButton = document.createElement('button');
      keyButton.classList.add('keyboard__button');
      keyButton.dataset.char = key;

      switch (key) {
        case 'Space':
          keyButton.classList.add('keyboard__button_space');
          break;
        case 'Backquote':
          keyButton.classList.add('keyboard__button_backquote');
          break;
        case 'Tab':
          keyButton.classList.add('keyboard__button_tab');
          break;
        case 'CapsLock':
          keyButton.classList.add('keyboard__button_capslock');
          break;
        case 'ShiftLeft':
          keyButton.classList.add('keyboard__button_lshift');
          break;
        case 'ControlLeft':
          keyButton.classList.add('keyboard__button_lctrl');
          break;
        case 'MetaLeft':
          keyButton.classList.add('keyboard__button_win');
          break;
        case 'AltLeft':
          keyButton.classList.add('keyboard__button_lalt');
          break;
        case 'AltRight':
          keyButton.classList.add('keyboard__button_ralt');
          break;
        case 'ShiftRight':
          keyButton.classList.add('keyboard__button_rshift');
          break;
        case 'ControlRight':
          keyButton.classList.add('keyboard__button_rctrl');
          break;
        case 'ArrowLeft':
          keyButton.classList.add('keyboard__button_arrowleft');
          break;
        case 'ArrowDown':
          keyButton.classList.add('keyboard__button_arrowdown');
          break;
        case 'ArrowRight':
          keyButton.classList.add('keyboard__button_arrowright');
          break;
        case 'ArrowUp':
          keyButton.classList.add('keyboard__button_arrowup');
          break;
        case 'Enter':
          keyButton.classList.add('keyboard__button_enter');
          break;
        case 'Delete':
          keyButton.classList.add('keyboard__button_del');
          break;
        case 'Backspace':
          keyButton.classList.add('keyboard__button_back');
          break;
        default:
          break;
      }

      if (lang === 'ru' && obj[key][lang]) {
        if (obj[key][lang].sup) {
          keyButton.insertAdjacentHTML(
            'afterbegin',
            `<span>${obj[key][lang].sup}</span>${obj[key][lang].char}`,
          );
        } else {
          keyButton.textContent = obj[key][lang].char;
        }
      } else if (obj[key].en.sup) {
        keyButton.insertAdjacentHTML(
          'afterbegin',
          `<span>${obj[key].en.sup}</span>${obj[key].en.char}`,
        );
      } else {
        keyButton.textContent = obj[key].en.char;
      }

      document.body
        .querySelector('.keyboard__wrapper')
        .insertAdjacentElement('beforeend', keyButton);
    }
  }
}

function translate(obj, lang) {
  const key = document.querySelectorAll('.keyboard__button');

  key.forEach((elem) => {
    const item = elem;
    if (obj[elem.dataset.char][lang] && lang === 'ru') {
      if (obj[elem.dataset.char][lang].sup) {
        item.innerHTML = '';
        elem.insertAdjacentHTML(
          'afterbegin',
          `<span>${obj[elem.dataset.char][lang].sup}</span>${
            obj[elem.dataset.char][lang].char
          }`,
        );
      } else {
        item.textContent = obj[elem.dataset.char][lang].char;
      }
    } else if (obj[elem.dataset.char].en.sup) {
      item.innerHTML = '';
      elem.insertAdjacentHTML(
        'afterbegin',
        `<span>${obj[elem.dataset.char].en.sup}</span>${
          obj[elem.dataset.char].en.char
        }`,
      );
    } else {
      item.textContent = obj[elem.dataset.char].en.char;
    }
  });
}

function clickOnButton() {
  const keyboard = document.querySelectorAll('.keyboard__button');
  const textarea = document.querySelector('.keyboard__textarea');

  let capsLock = true;
  let shiftActive = false;
  let altActive = false;
  let ctrlActive = false;
  let copyText = '';
  let isEnter = true;
  const arrReturnText = [];
  const newArrReturnText = [];
  let delSymb = '';

  // Installation of the lowerCase register
  keyboard.forEach((item) => {
    const key = item;
    if (
      item.dataset.char.includes('Key')
      || item.dataset.char.includes('Bracke')
      || item.dataset.char.includes('Semicolon')
      || item.dataset.char.includes('Quote')
      || item.dataset.char.includes('Comma')
      || item.dataset.char.includes('Period')
      || item.dataset.char.includes('Backquote')
    ) {
      key.textContent = item.textContent.toLowerCase();
    }
  });

  // Processing functions
  function btnDown(e) {
    if (e.target.closest('.keyboard__button') || e.code) {
      if (
        document.querySelector('textarea').selectionStart
        === document.querySelector('textarea').selectionEnd
      ) {
        document.querySelector('textarea').scrollTop = document.querySelector('textarea').scrollHeight;
      }

      const currentLang = localStorage.getItem('lang');
      let start = textarea.selectionStart;
      const end = textarea.selectionEnd;

      const startStr = textarea.textContent.slice(0, start);
      const endStr = textarea.textContent.slice(end);

      // variables for arrow control up, down
      let arr = textarea.textContent.split('\n');
      let currentSelect = textarea.selectionStart;
      let rows = 0;
      let value = 0;
      let sumArrLength = 0;

      keyboard.forEach((item) => {
        if (
          item.dataset.char === e.target.dataset.char
          || item.dataset.char === e.code
        ) {
          e.preventDefault();
          item.classList.add('keyboard__button_active');
          let needPosition = currentSelect - (value - arr[rows].length);
          let newValue = 0;
          let newStr = '';
          let backdel = '';

          switch (e.target.dataset.char || e.code) {
            case 'Space':
              setTimeout(() => {
                if (start + 1 === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  start += 1;
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              textarea.textContent = `${startStr} ${endStr}`;
              textarea.value = `${startStr} ${endStr}`;

              break;
            case 'Backquote':
              setTimeout(() => {
                if (start + 1 === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  start += 1;
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              if (shiftActive) {
                if (keyObj[item.dataset.char][currentLang]) {
                  if (keyObj[item.dataset.char][currentLang].sup) {
                    textarea.textContent = startStr
                      + keyObj[item.dataset.char][currentLang].sup
                      + endStr;
                  } else {
                    textarea.textContent = startStr
                      + keyObj[item.dataset.char][
                        currentLang
                      ].char.toUpperCase()
                      + endStr;
                  }
                } else {
                  textarea.textContent = startStr + keyObj[item.dataset.char].en.sup + endStr;
                }
              } else if (keyObj[item.dataset.char][currentLang]) {
                textarea.textContent = startStr
                    + keyObj[item.dataset.char][currentLang].char
                    + endStr;
              } else {
                textarea.textContent = startStr + keyObj[item.dataset.char].en.char + endStr;
              }
              textarea.value = textarea.textContent;

              break;
            case 'Tab':
              setTimeout(() => {
                if (start + 1 === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  textarea.selectionEnd = start + '\t'.length;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              textarea.textContent = `${startStr}\t${endStr}`;
              textarea.value = textarea.textContent;
              break;
            case 'CapsLock':
              if (capsLock) {
                capsLock = false;
                keyboard.forEach((element) => {
                  const elem = element;
                  if (
                    elem.dataset.char.includes('Key')
                    || elem.dataset.char.includes('Bracke')
                    || elem.dataset.char.includes('Semicolon')
                    || elem.dataset.char.includes('Quote')
                    || elem.dataset.char.includes('Comma')
                    || elem.dataset.char.includes('Period')
                    || elem.dataset.char.includes('Backquote')
                  ) {
                    elem.textContent = elem.textContent.toUpperCase();
                  }
                });
              } else {
                capsLock = true;
                keyboard.forEach((element) => {
                  const elem = element;
                  if (
                    elem.dataset.char.includes('Key')
                    || elem.dataset.char.includes('Bracke')
                    || elem.dataset.char.includes('Semicolon')
                    || elem.dataset.char.includes('Quote')
                    || elem.dataset.char.includes('Comma')
                    || elem.dataset.char.includes('Period')
                    || elem.dataset.char.includes('Backquote')
                  ) {
                    elem.textContent = elem.textContent.toLowerCase();
                  }
                });
              }
              break;
            case 'ShiftLeft':
            case 'ShiftRight':
              shiftActive = true;

              if (capsLock) {
                keyboard.forEach((element) => {
                  const elem = element;
                  if (
                    elem.dataset.char.includes('Key')
                    || elem.dataset.char.includes('Bracke')
                    || elem.dataset.char.includes('Semicolon')
                    || elem.dataset.char.includes('Quote')
                    || elem.dataset.char.includes('Comma')
                    || elem.dataset.char.includes('Period')
                    || elem.dataset.char.includes('Backquote')
                  ) {
                    elem.textContent = elem.textContent.toUpperCase();
                  }
                });
              } else {
                keyboard.forEach((element) => {
                  const elem = element;
                  if (
                    elem.dataset.char.includes('Key')
                    || elem.dataset.char.includes('Bracke')
                    || elem.dataset.char.includes('Semicolon')
                    || elem.dataset.char.includes('Quote')
                    || elem.dataset.char.includes('Comma')
                    || elem.dataset.char.includes('Period')
                    || elem.dataset.char.includes('Backquote')
                  ) {
                    elem.textContent = elem.textContent.toLowerCase();
                  }
                });
              }
              break;
            case 'ControlLeft':
            case 'ControlRight':
              ctrlActive = true;
              break;
            case 'MetaLeft':
              // keyButton.classList.add("keyboard__button_win");
              break;
            case 'AltLeft':
            case 'AltRight':
              altActive = true;
              break;
            case 'ArrowLeft':
              if (currentSelect !== 0) {
                currentSelect -= 1;
                textarea.selectionEnd = currentSelect;
                textarea.selectionStart = textarea.selectionEnd;
              }
              break;
            case 'ArrowDown':
              arr.forEach((element) => {
                sumArrLength += element.length;
                if (currentSelect > sumArrLength) {
                  rows += 1;
                  sumArrLength += 1;
                }
              });

              for (let i = 0; i <= rows; i += 1) {
                value += arr[i].length;
                if (currentSelect > value) {
                  value += 1;
                }
              }

              needPosition = currentSelect - (value - arr[rows].length);
              newValue = 0;

              for (let i = 0; i <= rows; i += 1) {
                newValue += arr[i].length + 1;
              }

              if (arr.length - 1 !== rows) {
                if (needPosition >= arr[rows + 1].length + 1) {
                  textarea.selectionEnd = newValue + arr[rows + 1].length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  textarea.selectionEnd = newValue + needPosition;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }

              break;
            case 'ArrowRight':
              currentSelect += 1;
              textarea.selectionEnd = currentSelect;
              textarea.selectionStart = textarea.selectionEnd;
              break;
            case 'ArrowUp':
              arr = textarea.textContent.split('\n');
              currentSelect = textarea.selectionStart;
              rows = 0;
              value = 0;
              sumArrLength = 0;

              if (currentSelect > arr[0].length) {
                arr.forEach((element) => {
                  sumArrLength += element.length;
                  if (currentSelect > sumArrLength) {
                    rows += 1;
                    sumArrLength += 1;
                  }
                });

                for (let i = 0; i <= rows; i += 1) {
                  value += arr[i].length;
                  if (currentSelect > value) {
                    value += 1;
                  }
                }

                needPosition = currentSelect - (value - arr[rows].length);
                newValue = 0;

                for (let i = 0; i < rows; i += 1) {
                  newValue += arr[i].length + 1;
                }

                if (needPosition >= arr[rows - 1].length + 1) {
                  newValue -= 1;
                  textarea.selectionEnd = newValue;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  textarea.selectionEnd = newValue - (arr[rows - 1].length + 1) + needPosition;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }
              break;
            case 'Enter':
              setTimeout(() => {
                if (start + 1 === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  start += 1;
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              textarea.textContent = `${startStr}\n${endStr}`;

              textarea.value = textarea.textContent;

              break;
            case 'Delete':
              setTimeout(() => {
                if (start === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              if (isEnter) {
                newArrReturnText.push(arrReturnText[arrReturnText.length - 1]);
                newArrReturnText.push(
                  textarea.textContent.slice(0, textarea.textContent.length - 1),
                );
                isEnter = false;
              }

              if (start === end) {
                for (let i = 0; i < textarea.textContent.length; i += 1) {
                  if (i !== start) newStr += textarea.textContent[i];
                }
              } else {
                newStr = startStr + endStr;
              }

              textarea.textContent = newStr;
              textarea.value = textarea.textContent;
              break;
            case 'Backspace':
              setTimeout(() => {
                if (start === textarea.textContent.length + 1) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else if (start === 0) {
                  textarea.selectionEnd = 0;
                  textarea.selectionStart = textarea.selectionEnd;
                } else if (start === end) {
                  start -= 1;
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              if (isEnter) {
                newArrReturnText.push(arrReturnText[arrReturnText.length - 1]);
                newArrReturnText.push(
                  textarea.textContent.slice(0, textarea.textContent.length - 1),
                );
                isEnter = false;
              }

              if (start === end) {
                for (let i = 0; i < textarea.textContent.length; i += 1) {
                  if (i === start - 1) {
                    delSymb += textarea.textContent[i];
                  } else {
                    backdel += textarea.textContent[i];
                  }
                }
              } else {
                delSymb = textarea.textContent.slice(start, end);
                backdel = startStr + endStr;
              }
              textarea.textContent = backdel;
              textarea.value = textarea.textContent;

              break;
            default:
              setTimeout(() => {
                if (start + 1 === textarea.textContent.length) {
                  textarea.selectionEnd = textarea.textContent.length;
                  textarea.selectionStart = textarea.selectionEnd;
                } else {
                  start += 1;
                  textarea.selectionEnd = start;
                  textarea.selectionStart = textarea.selectionEnd;
                }
              }, 0);

              if (ctrlActive) {
                if (e.target.dataset.char === 'KeyZ' || e.code === 'KeyZ') {
                  if (!isEnter) {
                    newArrReturnText.pop();
                    textarea.textContent = newArrReturnText.pop();
                    textarea.value = textarea.textContent;
                    isEnter = true;
                  } else {
                    textarea.textContent = newArrReturnText.pop();
                    textarea.value = textarea.textContent;
                  }
                  setTimeout(() => {
                    textarea.selectionEnd = currentSelect + delSymb.length;
                    textarea.selectionStart = textarea.selectionEnd;
                  }, 0);

                  setTimeout(() => {
                    delSymb = '';
                  }, 0);
                } else if (
                  e.target.dataset.char === 'KeyC'
                  || e.code === 'KeyC'
                ) {
                  copyText = window.getSelection().toString();
                } else if (
                  e.target.dataset.char === 'KeyV'
                  || e.code === 'KeyV'
                ) {
                  setTimeout(() => {
                    textarea.selectionEnd = +start + +copyText.length - 1;
                    textarea.selectionStart = textarea.selectionEnd;
                  }, 0);

                  if (start !== end || start === end) {
                    textarea.textContent = startStr + copyText + endStr;
                    textarea.value = textarea.textContent;
                  } else {
                    textarea.textContent += copyText;
                    textarea.value = textarea.textContent;
                  }
                }
              } else if (capsLock) {
                if (shiftActive) {
                  if (
                    item.dataset.char.includes('Digit')
                    || item.dataset.char.includes('Backquote')
                    || item.dataset.char.includes('Minus')
                    || item.dataset.char.includes('Equal')
                    || item.dataset.char === 'Backslash'
                  ) {
                    if (keyObj[item.dataset.char][currentLang]) {
                      textarea.textContent = startStr
                        + keyObj[item.dataset.char][currentLang].sup
                        + endStr;
                    } else {
                      textarea.textContent = startStr + keyObj[item.dataset.char].en.sup + endStr;
                    }
                  } else {
                    textarea.textContent = startStr + item.textContent.toUpperCase() + endStr;
                  }
                } else if (
                  item.dataset.char.includes('Digit')
                    || item.dataset.char.includes('Backquote')
                    || item.dataset.char.includes('Minus')
                    || item.dataset.char.includes('Equal')
                    || item.dataset.char === 'Backslash'
                ) {
                  if (keyObj[item.dataset.char][currentLang]) {
                    textarea.textContent = startStr
                        + keyObj[item.dataset.char][currentLang].char
                        + endStr;
                  } else {
                    textarea.textContent = startStr + keyObj[item.dataset.char].en.char + endStr;
                  }
                } else {
                  textarea.textContent = startStr + item.textContent.toLowerCase() + endStr;
                }
                textarea.value = textarea.textContent;
              } else {
                if (shiftActive) {
                  if (
                    item.dataset.char.includes('Digit')
                    || item.dataset.char.includes('Backquote')
                    || item.dataset.char.includes('Minus')
                    || item.dataset.char.includes('Equal')
                    || item.dataset.char === 'Backslash'
                  ) {
                    if (keyObj[item.dataset.char][currentLang]) {
                      textarea.textContent = startStr
                        + keyObj[item.dataset.char][currentLang].sup
                        + endStr;
                    } else {
                      textarea.textContent = startStr + keyObj[item.dataset.char].en.sup + endStr;
                    }
                  } else {
                    textarea.textContent = startStr + item.textContent.toLowerCase() + endStr;
                  }
                } else if (
                  item.dataset.char.includes('Digit')
                    || item.dataset.char.includes('Backquote')
                    || item.dataset.char.includes('Minus')
                    || item.dataset.char.includes('Equal')
                    || item.dataset.char === 'Backslash'
                ) {
                  if (keyObj[item.dataset.char][currentLang]) {
                    textarea.textContent = startStr
                        + keyObj[item.dataset.char][currentLang].char
                        + endStr;
                  } else {
                    textarea.textContent = startStr + keyObj[item.dataset.char].en.char + endStr;
                  }
                } else {
                  textarea.textContent = startStr + item.textContent.toUpperCase() + endStr;
                }
                textarea.value = textarea.textContent;
              }

              break;
          }
        }
      });
    }
  }

  function btnUp(e) {
    e.preventDefault();

    keyboard.forEach((item) => {
      if (
        item.dataset.char === e.target.dataset.char
        || item.dataset.char === e.code
      ) {
        if (e.target.dataset.char) {
          setTimeout(() => {
            item.classList.remove('keyboard__button_active');
          }, 300);
        } else {
          item.classList.remove('keyboard__button_active');
        }
        textarea.focus();

        switch (e.target.dataset.char || e.code) {
          case 'Space':
            if (isEnter) {
              newArrReturnText.push(textarea.textContent);
            }
            isEnter = true;
            arrReturnText.push(textarea.textContent);
            break;
          case 'Backquote':
            break;
          case 'Tab':
            isEnter = true;
            arrReturnText.push(textarea.textContent);
            break;
          case 'CapsLock':
            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            shiftActive = false;

            if (altActive) {
              let lang = localStorage.getItem('lang');

              if (lang === 'en') {
                lang = 'ru';
                localStorage.setItem('lang', lang);
                translate(keyObj, lang);
              } else {
                lang = 'en';
                localStorage.setItem('lang', lang);
                translate(keyObj, lang);
              }
            }

            if (capsLock) {
              keyboard.forEach((element) => {
                const elem = element;
                if (
                  elem.dataset.char.includes('Key')
                  || elem.dataset.char.includes('Bracke')
                  || elem.dataset.char.includes('Semicolon')
                  || elem.dataset.char.includes('Quote')
                  || elem.dataset.char.includes('Comma')
                  || elem.dataset.char.includes('Period')
                  || elem.dataset.char.includes('Backquote')
                ) {
                  elem.textContent = elem.textContent.toLowerCase();
                }
              });
            } else {
              keyboard.forEach((element) => {
                const elem = element;
                if (
                  elem.dataset.char.includes('Key')
                  || elem.dataset.char.includes('Bracke')
                  || elem.dataset.char.includes('Semicolon')
                  || elem.dataset.char.includes('Quote')
                  || elem.dataset.char.includes('Comma')
                  || elem.dataset.char.includes('Period')
                  || elem.dataset.char.includes('Backquote')
                ) {
                  elem.textContent = elem.textContent.toUpperCase();
                }
              });
            }
            break;
          case 'ControlLeft':
          case 'ControlRight':
            ctrlActive = false;
            break;
          case 'MetaLeft':
            break;
          case 'AltLeft':
          case 'AltRight':
            altActive = false;

            if (shiftActive) {
              let lang = localStorage.getItem('lang');

              if (lang === 'en') {
                lang = 'ru';
                localStorage.setItem('lang', lang);
                translate(keyObj, lang);
              } else {
                lang = 'en';
                localStorage.setItem('lang', lang);
                translate(keyObj, lang);
              }
            }
            break;
          case 'ArrowLeft':
            break;
          case 'ArrowDown':
            break;
          case 'ArrowRight':
            break;
          case 'ArrowUp':
            break;
          case 'Enter':
            isEnter = true;
            arrReturnText.push(textarea.textContent);
            break;
          case 'Delete':
            break;
          case 'Backspace':
            break;
          default:
            isEnter = true;
            arrReturnText.push(textarea.textContent);

            break;
        }
      }
    });
  }

  // Handling mouse events
  document.addEventListener('mousedown', btnDown);
  document.addEventListener('mouseup', btnUp);

  // Handling Keyboard Events
  document.addEventListener('keydown', btnDown);
  document.addEventListener('keyup', btnUp);
}

window.addEventListener('load', () => {
  let selectedLang = localStorage.getItem('lang');
  if (!selectedLang) {
    selectedLang = document.documentElement.lang;
    localStorage.setItem('lang', selectedLang);
  }

  generateKeyboard(keyObj, selectedLang);
  clickOnButton();
});
