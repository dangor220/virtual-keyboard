const keyObj = {
	Backquote: {
		en: {
			sup: "~",
			char: "`",
		},
		ru: {
			char: "ё",
		},
	},
	Digit1: {
		en: {
			sup: "!",
			char: "1",
		},
	},
	Digit2: {
		en: {
			sup: "@",
			char: "2",
		},
		ru: {
			sup: '"',
			char: "2",
		},
	},
	Digit3: {
		en: {
			sup: "#",
			char: "3",
		},
		ru: {
			sup: "№",
			char: "3",
		},
	},
	Digit4: {
		en: {
			sup: "$",
			char: "4",
		},
		ru: {
			sup: ";",
			char: "4",
		},
	},
	Digit5: {
		en: {
			sup: "%",
			char: "5",
		},
	},
	Digit6: {
		en: {
			sup: "^",
			char: "6",
		},
		ru: {
			sup: ":",
			char: "6",
		},
	},
	Digit7: {
		en: {
			sup: "&",
			char: "7",
		},
		ru: {
			sup: "?",
			char: "7",
		},
	},
	Digit8: {
		en: {
			sup: "*",
			char: "8",
		},
	},
	Digit9: {
		en: {
			sup: "(",
			char: "9",
		},
	},
	Digit0: {
		en: {
			sup: ")",
			char: "0",
		},
	},
	Minus: {
		en: {
			sup: "_",
			char: "-",
		},
	},
	Equal: {
		en: {
			sup: "+",
			char: "=",
		},
	},
	Backspace: {
		en: {
			char: "Backspace ",
		},
	},
	Tab: {
		en: {
			char: "Tab ",
		},
	},
	KeyQ: {
		en: {
			char: "Q",
		},
		ru: {
			char: "Й",
		},
	},
	KeyW: {
		en: {
			char: "W",
		},
		ru: {
			char: "Ц",
		},
	},
	KeyE: {
		en: {
			char: "E",
		},
		ru: {
			char: "У",
		},
	},
	KeyR: {
		en: {
			char: "R",
		},
		ru: {
			char: "К",
		},
	},
	KeyT: {
		en: {
			char: "T",
		},
		ru: {
			char: "Е",
		},
	},
	KeyY: {
		en: {
			char: "Y",
		},
		ru: {
			char: "Н",
		},
	},
	KeyU: {
		en: {
			char: "U",
		},
		ru: {
			char: "Г",
		},
	},
	KeyI: {
		en: {
			char: "I",
		},
		ru: {
			char: "Ш",
		},
	},
	KeyO: {
		en: {
			char: "O",
		},
		ru: {
			char: "Щ",
		},
	},
	KeyP: {
		en: {
			char: "P",
		},
		ru: {
			char: "З",
		},
	},
	BracketLeft: {
		en: {
			char: "[",
		},
		ru: {
			char: "Х",
		},
	},
	BracketRight: {
		en: {
			char: "]",
		},
		ru: {
			char: "Ъ",
		},
	},
	Backslash: {
		en: {
			sup: "/",
			char: "\\",
		},
	},
	Delete: {
		en: {
			char: "Del",
		},
	},
	CapsLock: {
		en: {
			char: "CapsLock",
		},
	},
	KeyA: {
		en: {
			char: "A",
		},
		ru: {
			char: "Ф",
		},
	},
	KeyS: {
		en: {
			char: "S",
		},
		ru: {
			char: "Ы",
		},
	},
	KeyD: {
		en: {
			char: "D",
		},
		ru: {
			char: "В",
		},
	},
	KeyF: {
		en: {
			char: "F",
		},
		ru: {
			char: "А",
		},
	},
	KeyG: {
		en: {
			char: "G",
		},
		ru: {
			char: "П",
		},
	},
	KeyH: {
		en: {
			char: "H",
		},
		ru: {
			char: "Р",
		},
	},
	KeyJ: {
		en: {
			char: "J",
		},
		ru: {
			char: "О",
		},
	},
	KeyK: {
		en: {
			char: "K",
		},
		ru: {
			char: "Л",
		},
	},
	KeyL: {
		en: {
			char: "L",
		},
		ru: {
			char: "Д",
		},
	},
	Semicolon: {
		en: {
			char: ";",
		},
		ru: {
			char: "Ж",
		},
	},
	Quote: {
		en: {
			char: "'",
		},
		ru: {
			char: "Э",
		},
	},
	Enter: {
		en: {
			char: "ENTER",
		},
	},
	ShiftLeft: {
		en: {
			char: "Shift",
		},
	},
	IntlBackslash: {
		en: {
			char: "\\",
		},
	},
	KeyZ: {
		en: {
			char: "Z",
		},
		ru: {
			char: "Я",
		},
	},
	KeyX: {
		en: {
			char: "X",
		},
		ru: {
			char: "Ч",
		},
	},
	KeyC: {
		en: {
			char: "C",
		},
		ru: {
			char: "С",
		},
	},
	KeyV: {
		en: {
			char: "V",
		},
		ru: {
			char: "М",
		},
	},
	KeyB: {
		en: {
			char: "B",
		},
		ru: {
			char: "И",
		},
	},
	KeyN: {
		en: {
			char: "N",
		},
		ru: {
			char: "Т",
		},
	},
	KeyM: {
		en: {
			char: "M",
		},
		ru: {
			char: "Ь",
		},
	},
	Comma: {
		en: {
			char: ",",
		},
		ru: {
			char: "Б",
		},
	},
	Period: {
		en: {
			char: ".",
		},
		ru: {
			char: "Ю",
		},
	},
	Slash: {
		en: {
			char: "/",
		},
		ru: {
			char: ".",
		},
	},
	ArrowUp: {
		en: {
			char: "",
		},
	},
	ShiftRight: {
		en: {
			char: "Shift",
		},
	},
	ControlLeft: {
		en: {
			char: "Ctrl",
		},
	},
	MetaLeft: {
		en: {
			char: "Win",
		},
	},
	AltLeft: {
		en: {
			char: "Alt",
		},
	},
	Space: {
		en: {
			char: "Space",
		},
	},
	AltRight: {
		en: {
			char: "Alt",
		},
	},
	ControlRight: {
		en: {
			char: "Ctrl",
		},
	},
	ArrowLeft: {
		en: {
			char: "",
		},
	},
	ArrowDown: {
		en: {
			char: "",
		},
	},
	ArrowRight: {
		en: {
			char: "",
		},
	},
};

window.addEventListener("load", () => {
	let selectedLang = localStorage.getItem("lang");
	if (!selectedLang) {
		selectedLang = document.documentElement.lang;
		localStorage.setItem("lang", selectedLang);
	}

	generateKeyboard(keyObj, selectedLang);
	clickOnButton();
});

function generateKeyboard(obj, lang) {
	let keyboardBlock = document.createElement("div");
	let keyboardTextarea = document.createElement("textarea");
	let keyboardWrapper = document.createElement("div");

	keyboardTextarea.scrollTop = keyboardTextarea.scrollHeight;
	
	keyboardBlock.classList.add("keyboard");
	keyboardBlock.classList.add("_container");

	keyboardTextarea.classList.add("keyboard__textarea");
	keyboardWrapper.classList.add("keyboard__wrapper");

	keyboardTextarea.placeholder = `Разработано в Windows\nСмена раскладки: Alt+Shift`

	document.body.insertAdjacentElement("afterbegin", keyboardBlock);
	document.body
		.querySelector(".keyboard")
		.insertAdjacentElement("afterbegin", keyboardWrapper);
	document.body
		.querySelector(".keyboard")
		.insertAdjacentElement("afterbegin", keyboardTextarea);

	for (let key in obj) {
		let keyButton = document.createElement("button");
		keyButton.classList.add("keyboard__button");
		keyButton.dataset.char = key;

		switch (key) {
			case "Space":
				keyButton.classList.add("keyboard__button_space");
				break;
			case "Backquote":
				keyButton.classList.add("keyboard__button_backquote");
				break;
			case "Tab":
				keyButton.classList.add("keyboard__button_tab");
				break;
			case "CapsLock":
				keyButton.classList.add("keyboard__button_capslock");
				break;
			case "ShiftLeft":
				keyButton.classList.add("keyboard__button_lshift");
				break;
			case "ControlLeft":
				keyButton.classList.add("keyboard__button_lctrl");
				break;
			case "MetaLeft":
				keyButton.classList.add("keyboard__button_win");
				break;
			case "AltLeft":
				keyButton.classList.add("keyboard__button_lalt");
				break;
			case "AltRight":
				keyButton.classList.add("keyboard__button_ralt");
				break;
			case "ShiftRight":
				keyButton.classList.add("keyboard__button_rshift");
				break;
			case "ControlRight":
				keyButton.classList.add("keyboard__button_rctrl");
				break;
			case "ArrowLeft":
				keyButton.classList.add("keyboard__button_arrowleft");
				break;
			case "ArrowDown":
				keyButton.classList.add("keyboard__button_arrowdown");
				break;
			case "ArrowRight":
				keyButton.classList.add("keyboard__button_arrowright");
				break;
			case "ArrowUp":
				keyButton.classList.add("keyboard__button_arrowup");
				break;
			case "Enter":
				keyButton.classList.add("keyboard__button_enter");
				break;
			case "Delete":
				keyButton.classList.add("keyboard__button_del");
				break;
			case "Backspace":
				keyButton.classList.add("keyboard__button_back");
				break;
			default:
				break;
		}

		if (lang === "ru" && obj[key][lang]) {
			if (obj[key][lang].sup) {
				keyButton.insertAdjacentHTML(
					"afterbegin",
					`<span>${obj[key][lang].sup}</span>${obj[key][lang].char}`
				);
			} else {
				keyButton.textContent = obj[key][lang].char;
			}
		} else {
			if (obj[key].en.sup) {
				keyButton.insertAdjacentHTML(
					"afterbegin",
					`<span>${obj[key].en.sup}</span>${obj[key].en.char}`
				);
			} else {
				keyButton.textContent = obj[key].en.char;
			}
		}

		document.body
			.querySelector(".keyboard__wrapper")
			.insertAdjacentElement("beforeend", keyButton);
	}
}

function translate(obj, lang) {
	let key = document.querySelectorAll(".keyboard__button");

	key.forEach((elem) => {
		if (obj[elem.dataset.char][lang] && lang === "ru") {
			if (obj[elem.dataset.char][lang].sup) {
				elem.innerHTML = "";
				elem.insertAdjacentHTML(
					"afterbegin",
					`<span>${obj[elem.dataset.char][lang].sup}</span>${
						obj[elem.dataset.char][lang].char
					}`
				);
			} else {
				elem.textContent = obj[elem.dataset.char][lang].char;
			}
		} else {
			if (obj[elem.dataset.char].en.sup) {
				elem.innerHTML = "";
				elem.insertAdjacentHTML(
					"afterbegin",
					`<span>${obj[elem.dataset.char].en.sup}</span>${
						obj[elem.dataset.char].en.char
					}`
				);
			} else {
				elem.textContent = obj[elem.dataset.char].en.char;
			}
		}
	});
}
function clickOnButton() {
	const keyboard = document.querySelectorAll(".keyboard__button");
	const textarea = document.querySelector(".keyboard__textarea");

	let capsLock = true;
	let shiftActive = false;
	let altActive = false;
	let ctrlActive = false;
	let copyText = "";
	let isEnter = true;
	let arrReturnText = [];
	let newArrReturnText = [];
	let delSymb = '';

	// Installation of the lowerCase register
	keyboard.forEach((item) => {
		if (
			item.dataset.char.includes("Key") ||
			item.dataset.char.includes("Bracke") ||
			item.dataset.char.includes("Semicolon") ||
			item.dataset.char.includes("Quote") ||
			item.dataset.char.includes("Comma") ||
			item.dataset.char.includes("Period") ||
			item.dataset.char.includes("Backquote")
		) {
			item.textContent = item.textContent.toLowerCase();
		}
	});

	// Handling mouse events
	document.addEventListener("mousedown", btnDown);
	document.addEventListener("mouseup", btnUp);

	// Handling Keyboard Events
	document.addEventListener("keydown", btnDown);
	document.addEventListener("keyup", btnUp);

	// Processing functions
	function btnDown(e) {
		if (e.target.closest(".keyboard__button") || e.code) {

			if(document.querySelector("textarea").selectionStart == document.querySelector("textarea").selectionEnd) {
				document.querySelector("textarea").scrollTop = document.querySelector("textarea").scrollHeight;
			}

			let currentLang = localStorage.getItem("lang");
			let start = textarea.selectionStart;
			let end = textarea.selectionEnd;

			let startStr = textarea.textContent.slice(0, start);
			let endStr = textarea.textContent.slice(end);

			// variables for arrow control up, down
			let arr = textarea.textContent.split("\n");
			let currentSelect = textarea.selectionStart;
			let rows = 0;
			let value = 0;
			let sumArrLength = 0;

			keyboard.forEach((item) => {
				if (
					item.dataset.char === e.target.dataset.char ||
					item.dataset.char === e.code
				) {
					e.preventDefault();
					item.classList.add("keyboard__button_active");
					let needPosition = currentSelect - (value - arr[rows].length);
					let newValue = 0;
					let newStr = "";
					let backdel = "";

					switch (e.target.dataset.char || e.code) {
						case "Space":
							setTimeout(function () {
								if (start + 1 === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd = ++start;
								}
							}, 0);

							textarea.textContent = startStr + " " + endStr;
							textarea.value = startStr + " " + endStr;

							break;
						case "Backquote":
							setTimeout(function () {
								if (start + 1 === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd = ++start;
								}
							}, 0);

							if (shiftActive) {
								if (keyObj[item.dataset.char][currentLang]) {
									if (keyObj[item.dataset.char][currentLang].sup) {
										textarea.textContent =
											startStr +
											keyObj[item.dataset.char][currentLang].sup +
											endStr;
									} else {
										textarea.textContent =
											startStr +
											keyObj[item.dataset.char][
												currentLang
											].char.toUpperCase() +
											endStr;
									}
								} else {
									textarea.textContent =
										startStr + keyObj[item.dataset.char].en.sup + endStr;
								}
							} else {
								if (keyObj[item.dataset.char][currentLang]) {
									textarea.textContent =
										startStr +
										keyObj[item.dataset.char][currentLang].char +
										endStr;
								} else {
									textarea.textContent =
										startStr + keyObj[item.dataset.char].en.char + endStr;
								}
							}
							textarea.value = textarea.textContent;

							break;
						case "Tab":

							setTimeout(function () {
								if (start + 1 === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd =
										start + "\t".length;
								}
							}, 0);

							textarea.textContent = startStr + "\t" + endStr;
							textarea.value = textarea.textContent;
							break;
						case "CapsLock":
							if (capsLock) {
								capsLock = false;
								keyboard.forEach((item) => {
									if (
										item.dataset.char.includes("Key") ||
										item.dataset.char.includes("Bracke") ||
										item.dataset.char.includes("Semicolon") ||
										item.dataset.char.includes("Quote") ||
										item.dataset.char.includes("Comma") ||
										item.dataset.char.includes("Period") ||
										item.dataset.char.includes("Backquote")
									) {
										item.textContent = item.textContent.toUpperCase();
									}
								});
							} else {
								capsLock = true;
								keyboard.forEach((item) => {
									if (
										item.dataset.char.includes("Key") ||
										item.dataset.char.includes("Bracke") ||
										item.dataset.char.includes("Semicolon") ||
										item.dataset.char.includes("Quote") ||
										item.dataset.char.includes("Comma") ||
										item.dataset.char.includes("Period") ||
										item.dataset.char.includes("Backquote")
									) {
										item.textContent = item.textContent.toLowerCase();
									}
								});
							}
							break;
						case "ShiftLeft":
						case "ShiftRight":
							shiftActive = true;

							if (capsLock) {
								keyboard.forEach((item) => {
									if (
										item.dataset.char.includes("Key") ||
										item.dataset.char.includes("Bracke") ||
										item.dataset.char.includes("Semicolon") ||
										item.dataset.char.includes("Quote") ||
										item.dataset.char.includes("Comma") ||
										item.dataset.char.includes("Period") ||
										item.dataset.char.includes("Backquote")
									) {
										item.textContent = item.textContent.toUpperCase();
									}
								});
							} else {
								keyboard.forEach((item) => {
									if (
										item.dataset.char.includes("Key") ||
										item.dataset.char.includes("Bracke") ||
										item.dataset.char.includes("Semicolon") ||
										item.dataset.char.includes("Quote") ||
										item.dataset.char.includes("Comma") ||
										item.dataset.char.includes("Period") ||
										item.dataset.char.includes("Backquote")
									) {
										item.textContent = item.textContent.toLowerCase();
									}
								});
							}
							break;
						case "ControlLeft":
						case "ControlRight":
							ctrlActive = true;
							break;
						case "MetaLeft":
							// keyButton.classList.add("keyboard__button_win");
							break;
						case "AltLeft":
						case "AltRight":
							altActive = true;
							break;
						case "ArrowLeft":
							if (currentSelect !== 0) {
								textarea.selectionStart = textarea.selectionEnd =
									--currentSelect;
							}
							break;
						case "ArrowDown":
					
							arr.forEach((item) => {
								sumArrLength += item.length;
								if (currentSelect > sumArrLength) {
									rows += 1;
									sumArrLength += 1;
								}
							});

							for (let i = 0; i <= rows; i++) {
								value += arr[i].length;
								if (currentSelect > value) {
									value += 1;
								}
							}

							needPosition = currentSelect - (value - arr[rows].length);
							newValue = 0;
							
							
						
							for (let i = 0; i <= rows; i++) {
								newValue += arr[i].length + 1;
								
							}

							if (arr.length - 1 !== rows) {
								
								if (needPosition >= arr[rows + 1].length + 1) {
									textarea.selectionStart = textarea.selectionEnd =
										newValue + arr[rows + 1].length;
								} else {
									textarea.selectionStart = textarea.selectionEnd =
										newValue + needPosition;
								}
							}

							break;
						case "ArrowRight":
							textarea.selectionStart = textarea.selectionEnd = ++currentSelect;
							break;
						case "ArrowUp":
							arr = textarea.textContent.split("\n");
							currentSelect = textarea.selectionStart;
							rows = 0;
							value = 0;
							sumArrLength = 0;

							if (currentSelect > arr[0].length) {
								arr.forEach((item) => {
									sumArrLength += item.length;
									if (currentSelect > sumArrLength) {
										rows += 1;
										sumArrLength += 1;
									}
								});

								for (let i = 0; i <= rows; i++) {
									value += arr[i].length;
									if (currentSelect > value) {
										value += 1;
									}
								}

								let needPosition = currentSelect - (value - arr[rows].length);
								let newValue = 0;

								for (let i = 0; i < rows; i++) {
									newValue += arr[i].length + 1;
								}

								if (needPosition >= arr[rows - 1].length + 1) {
									textarea.selectionStart = textarea.selectionEnd = --newValue;
								} else {
									textarea.selectionStart = textarea.selectionEnd =
										newValue - (arr[rows - 1].length + 1) + needPosition;
								}
							}
							break;
						case "Enter":
							setTimeout(function () {
								if (start + 1 === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd = ++start;
								}
							}, 0);

							textarea.textContent = startStr + "\n" + endStr;

							textarea.value = textarea.textContent;

							break;
						case "Delete":
							setTimeout(function () {
								if (start === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd = start;
								}
							}, 0);

							if (isEnter) {
								newArrReturnText.push(arrReturnText[arrReturnText.length - 1]);
								newArrReturnText.push(
									textarea.textContent.slice(0, textarea.textContent.length - 1)
								);
								isEnter = false;
							}

							

							if (start === end) {
								for (let i = 0; i < textarea.textContent.length; i++) {
									if (i === start) continue;
									newStr += textarea.textContent[i];
								}
							} else {
								newStr = startStr + endStr;
							}

							textarea.textContent = newStr;
							textarea.value = textarea.textContent;
							break;
						case "Backspace":
							setTimeout(function () {
								if (start === textarea.textContent.length + 1) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else if (start === 0) {
									textarea.selectionStart = textarea.selectionEnd = 0;
								} else if (start === end) {
									textarea.selectionStart = textarea.selectionEnd = --start;
								} else {
									textarea.selectionStart = textarea.selectionEnd = start;
								}
							}, 0);

							

							

							if (isEnter) {
								newArrReturnText.push(arrReturnText[arrReturnText.length - 1]);
								newArrReturnText.push(
									textarea.textContent.slice(0, textarea.textContent.length - 1)
								);
								isEnter = false;
							}

							

							if (start === end) {
								for (let i = 0; i < textarea.textContent.length; i++) {
									if (i === start - 1) {
										delSymb += textarea.textContent[i];
									} else {
										backdel += textarea.textContent[i];
									}
									
								}
							} else {
								delSymb = textarea.textContent.slice(start, end)
								backdel = startStr + endStr;
								
							}
							console.log(delSymb);
							textarea.textContent = backdel;
							textarea.value = textarea.textContent;

							break;
						default:
							setTimeout(function () {
								if (start + 1 === textarea.textContent.length) {
									textarea.selectionStart = textarea.selectionEnd =
										textarea.textContent.length;
								} else {
									textarea.selectionStart = textarea.selectionEnd = ++start;
								}
							}, 0);

							if (ctrlActive) {
								if (e.target.dataset.char === "KeyZ" || e.code === "KeyZ") {
									
									if (!isEnter) {
										newArrReturnText.pop();
										textarea.textContent = newArrReturnText.pop();
										textarea.value = textarea.textContent;
										isEnter = true;
									} else {
										textarea.textContent = newArrReturnText.pop();
										textarea.value = textarea.textContent;
									}
									setTimeout(function () {
											textarea.selectionStart = textarea.selectionEnd = currentSelect + delSymb.length;
									}, 0);

									setTimeout(function () {	
										delSymb = '';
								}, 0);
								
								
									
								} else if (
									e.target.dataset.char === "KeyC" ||
									e.code === "KeyC"
								) {
									copyText = window.getSelection().toString();
								} else if (
									e.target.dataset.char === "KeyV" ||
									e.code === "KeyV"
								) {
									setTimeout(function () {
										textarea.selectionStart = textarea.selectionEnd =
											+start + +copyText.length - 1;
									}, 0);

									if (start !== end || start === end) {
										textarea.textContent = startStr + copyText + endStr;
										textarea.value = textarea.textContent;
									} else {
										textarea.textContent += copyText;
										textarea.value = textarea.textContent;
									}
								}
							} else if (capsLock) {
								if (shiftActive) {
									if (
										item.dataset.char.includes("Digit") ||
										item.dataset.char.includes("Backquote") ||
										item.dataset.char.includes("Minus") ||
										item.dataset.char.includes("Equal") ||
										item.dataset.char === "Backslash"
									) {
										if (keyObj[item.dataset.char][currentLang]) {
											textarea.textContent =
												startStr +
												keyObj[item.dataset.char][currentLang].sup +
												endStr;
										} else {
											textarea.textContent =
												startStr + keyObj[item.dataset.char].en.sup + endStr;
										}
									} else {
										textarea.textContent =
											startStr + item.textContent.toUpperCase() + endStr;
									}
								} else {
									if (
										item.dataset.char.includes("Digit") ||
										item.dataset.char.includes("Backquote") ||
										item.dataset.char.includes("Minus") ||
										item.dataset.char.includes("Equal") ||
										item.dataset.char === "Backslash"
									) {
										if (keyObj[item.dataset.char][currentLang]) {
											textarea.textContent =
												startStr +
												keyObj[item.dataset.char][currentLang].char +
												endStr;
										} else {
											textarea.textContent =
												startStr + keyObj[item.dataset.char].en.char + endStr;
										}
									} else {
										textarea.textContent =
											startStr + item.textContent.toLowerCase() + endStr;
									}
								}
								textarea.value = textarea.textContent;
							} else {
								if (shiftActive) {
									if (
										item.dataset.char.includes("Digit") ||
										item.dataset.char.includes("Backquote") ||
										item.dataset.char.includes("Minus") ||
										item.dataset.char.includes("Equal") ||
										item.dataset.char === "Backslash"
									) {
										if (keyObj[item.dataset.char][currentLang]) {
											textarea.textContent =
												startStr +
												keyObj[item.dataset.char][currentLang].sup +
												endStr;
										} else {
											textarea.textContent =
												startStr + keyObj[item.dataset.char].en.sup + endStr;
										}
									} else {
										textarea.textContent =
											startStr + item.textContent.toLowerCase() + endStr;
									}
								} else {
									if (
										item.dataset.char.includes("Digit") ||
										item.dataset.char.includes("Backquote") ||
										item.dataset.char.includes("Minus") ||
										item.dataset.char.includes("Equal") ||
										item.dataset.char === "Backslash"
									) {
										if (keyObj[item.dataset.char][currentLang]) {
											textarea.textContent =
												startStr +
												keyObj[item.dataset.char][currentLang].char +
												endStr;
										} else {
											textarea.textContent =
												startStr + keyObj[item.dataset.char].en.char + endStr;
										}
									} else {
										textarea.textContent =
											startStr + item.textContent.toUpperCase() + endStr;
									}
								}
								textarea.value = textarea.textContent;
							}

							break;
					}
				}
			});
		}
	}
	function btnUp(e) {
		e.preventDefault();

		keyboard.forEach((item) => {
			if (
				item.dataset.char === e.target.dataset.char ||
				item.dataset.char === e.code
			) {
				if (e.target.dataset.char) {
					setTimeout(() => {
						item.classList.remove("keyboard__button_active");
					}, 300);
				} else {
					item.classList.remove("keyboard__button_active");
				}
				textarea.focus();

				switch (e.target.dataset.char || e.code) {
					case "Space":
						if (isEnter) {
							newArrReturnText.push(textarea.textContent);
						}
						isEnter = true;
						arrReturnText.push(textarea.textContent);
						break;
					case "Backquote":
						break;
					case "Tab":
						isEnter = true;
						arrReturnText.push(textarea.textContent);
						break;
					case "CapsLock":
						break;
					case "ShiftLeft":
					case "ShiftRight":
						shiftActive = false;

						if (altActive) {
							let lang = localStorage.getItem("lang");

							if (lang === "en") {
								lang = "ru";
								localStorage.setItem("lang", lang);
								translate(keyObj, lang);
							} else {
								lang = "en";
								localStorage.setItem("lang", lang);
								translate(keyObj, lang);
							}
						}

						if (capsLock) {
							keyboard.forEach((item) => {
								if (
									item.dataset.char.includes("Key") ||
									item.dataset.char.includes("Bracke") ||
									item.dataset.char.includes("Semicolon") ||
									item.dataset.char.includes("Quote") ||
									item.dataset.char.includes("Comma") ||
									item.dataset.char.includes("Period") ||
									item.dataset.char.includes("Backquote")
								) {
									item.textContent = item.textContent.toLowerCase();
								}
							});
						} else {
							keyboard.forEach((item) => {
								if (
									item.dataset.char.includes("Key") ||
									item.dataset.char.includes("Bracke") ||
									item.dataset.char.includes("Semicolon") ||
									item.dataset.char.includes("Quote") ||
									item.dataset.char.includes("Comma") ||
									item.dataset.char.includes("Period") ||
									item.dataset.char.includes("Backquote")
								) {
									item.textContent = item.textContent.toUpperCase();
								}
							});
						}
						break;
					case "ControlLeft":
					case "ControlRight":
						ctrlActive = false;
						break;
					case "MetaLeft":
						break;
					case "AltLeft":
					case "AltRight":
						altActive = false;

						if (shiftActive) {
							let lang = localStorage.getItem("lang");

							if (lang === "en") {
								lang = "ru";
								localStorage.setItem("lang", lang);
								translate(keyObj, lang);
							} else {
								lang = "en";
								localStorage.setItem("lang", lang);
								translate(keyObj, lang);
							}
						}
						break;
					case "ArrowLeft":
						break;
					case "ArrowDown":
						break;
					case "ArrowRight":
						break;
					case "ArrowUp":
						break;
					case "Enter":
						isEnter = true;
						arrReturnText.push(textarea.textContent);
						break;
					case "Delete":
						break;
					case "Backspace":
						break;
					default:
						isEnter = true;
						arrReturnText.push(textarea.textContent);

						break;
				}
			}
		});
	}
}
